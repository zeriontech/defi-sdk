// Copyright (C) 2020 Zerion Inc. <https://zerion.io>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity 0.7.3;

import { Input, Fee, Permit, TokenAmount, AmountType, PermitType } from "../shared/Structs.sol";
import { ERC20 } from "../interfaces/ERC20.sol";
import { SafeERC20 } from "../shared/SafeERC20.sol";

abstract contract BaseRouter {
    using SafeERC20 for ERC20;

    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    uint256 internal constant FEE_LIMIT = 1e16; // 1%
    uint256 internal constant DELIMITER = 1e18; // 100%

    event Executed(address indexed account, uint256 indexed share, address indexed beneficiary);
    event TokenTransfer(address indexed account, address indexed token, uint256 indexed amount);

    function callPermit(address token, Permit memory permit) internal {
        (bool success, bytes memory returnData) =
            // solhint-disable-next-line avoid-low-level-calls
            token.call(
                abi.encodePacked(getPermitSelector(permit.permitType), permit.permitCallData)
            );

        // assembly revert opcode is used here as `returnData`
        // is already bytes array generated by the callee's revert()
        // solhint-disable-next-line no-inline-assembly
        assembly {
            if eq(success, 0) {
                revert(add(returnData, 32), returndatasize())
            }
        }
    }

    function handleTokenInput(
        address account,
        address destination,
        Input memory input,
        Fee memory fee
    ) internal returns (uint256) {
        address token = input.tokenAmount.token;
        uint256 absoluteAmount = getAbsoluteAmount(account, input.tokenAmount);
        require(absoluteAmount > 0, "BR: zero amount");

        if (absoluteAmount > ERC20(token).allowance(account, address(this))) {
            callPermit(token, input.permit);
        }

        uint256 feeAmount = handleTokenFee(account, token, absoluteAmount, fee);
        uint256 inputAmount = absoluteAmount - feeAmount;

        ERC20(token).safeTransferFrom(account, destination, inputAmount, "BR");
        emit TokenTransfer(account, token, inputAmount);

        return inputAmount;
    }

    function handleETHInput(
        address account,
        address destination,
        Fee memory fee
    ) internal returns (uint256) {
        uint256 feeAmount = handleETHFee(fee);
        uint256 inputAmount = msg.value - feeAmount;

        transferEther(destination, msg.value - feeAmount, "UR: bad destination");
        emit TokenTransfer(account, ETH, msg.value - feeAmount);

        return inputAmount;
    }

    function handleTokenFee(
        address account,
        address token,
        uint256 absoluteAmount,
        Fee memory fee
    ) internal returns (uint256) {
        uint256 feeAmount = mul_(absoluteAmount, fee.share) / DELIMITER;

        if (feeAmount > 0) {
            ERC20(token).safeTransferFrom(account, fee.beneficiary, feeAmount, "BR");
        }

        return feeAmount;
    }

    function handleETHFee(Fee memory fee) internal returns (uint256) {
        uint256 feeAmount = mul_(msg.value, fee.share) / DELIMITER;

        if (feeAmount > 0) {
            transferEther(fee.beneficiary, feeAmount, "BR: bad beneficiary");
        }

        return feeAmount;
    }

    function getAbsoluteAmount(address account, TokenAmount memory tokenAmount)
        internal
        view
        returns (uint256)
    {
        address token = tokenAmount.token;
        AmountType amountType = tokenAmount.amountType;
        uint256 amount = tokenAmount.amount;

        require(
            amountType == AmountType.Relative || amountType == AmountType.Absolute,
            "BR: bad amount type"
        );

        if (amountType == AmountType.Relative) {
            require(amount <= DELIMITER, "BR: bad amount");
            if (amount == DELIMITER) {
                return ERC20(token).balanceOf(account);
            } else {
                return mul_(ERC20(token).balanceOf(account), amount) / DELIMITER;
            }
        } else {
            return amount;
        }
    }

    function getPermitSelector(PermitType permitType) internal pure returns (bytes4) {
        require(
            permitType == PermitType.EIP2612 ||
                permitType == PermitType.DAI ||
                permitType == PermitType.Yearn,
            "BR: permit is required but not provided"
        );

        // Constants of non-value type not yet implemented,
        // so we have to use else-if's.
        //    bytes4[3] internal constant PERMIT_SELECTORS = [
        //        // PermitType.EIP2612
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'))
        //        0xd505accf,
        //        // PermitType.DAI
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)'))
        //        0x8fcbaf0c,
        //        // PermitType.Yearn
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,bytes[65])'))
        //        0x53ab5ce3
        //    ];

        if (permitType == PermitType.EIP2612) {
            return 0xd505accf;
        } else if (permitType == PermitType.DAI) {
            return 0x8fcbaf0c;
        } else if (permitType == PermitType.Yearn) {
            return 0x53ab5ce3;
        } else {
            return bytes4(0);
        }
    }

    function transferEther(
        address to,
        uint256 amount,
        string memory error
    ) internal {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = to.call{ value: amount }(new bytes(0));
        require(success, error);
    }

    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "BR: mul_ overflow");

        return c;
    }

    function add_(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "BR: add_ overflow");

        return c;
    }
}
